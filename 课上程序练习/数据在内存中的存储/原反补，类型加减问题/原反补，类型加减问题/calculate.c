#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <math.h>
#include <string.h>


int main()
{

	


	////题一：
	//char a = -1;                 //原码 1000 0001   补码 1111 1111
	//signed char b = -1;          //原码 1000 0001   补码 1111 1111
	//unsigned char c = -1;        //原码 1000 0001   补码 1111 1111
	//                             //%d char转int型发生整形提升，有符号数发生整形提升前面补符号位，无符号数补0                 
	//printf("a=%d\n", a);         //提升后  a=1111 1111 1111 1111 1111 1111 1111 1111 (补码） 输出原码：1000 0000 0000 0000 0000 0000 0000 0001 =-1 
	//printf("b=%d\n", b);         //同上
	//printf("c=%d\n", c);         //提升后  c=0000 0000 0000 0000 0000 0000 1111 1111 （补码） 输出原码：0000 0000 0000 0000 0000 0000 1111 1111 =255




	////题二：                             //char取值范围 -128~127，-128为1000 0000 原因：如下
	//char a = -128;               //原码 1 1000 0000  符号位溢出后截断 变为1000 0000   补码：1 1000 0000再次截断1000 0000 
	//printf("%u\n", a);           //整形提升：1111 1111 1111 1111 1111 1111 1000 0000 （补码） 因为是无符号整形输出，所以输出该二进制对应的十进制数。


	////题三
	//char a = 128;                 //原码：0 1000 0000  符号位溢出后截断 变为1000 0000   补码：1 1000 0000再次截断1000 0000 
	//printf("%u\n", a);            //由此可看出答案同上




	////题四：
	//unsigned char i = 0;           //表示数值范围：0~255
	//for (i = 0; i <= 255; i++)     //一直在0~255之间，当i=255再加1时，发生截断后就又变为0了  1111 1111+0000 0001=1 | 0000 0000 =0
	//{
	//	printf("%d\n", i);         //所以一直循环，（死循环）重复打印0~255
	//	if (i <= 250)
	//	{
	//		Sleep(30);
	//	}
	//	else{
	//		Sleep(1000);
	//	}
	//}




	//题五：
	//unsigned int i ;           //表示数值范围：0~2^32-1
	//for (i = 9; i >=0; i--)     //一直在0~2^32-1之间，当i=0再减1时，发生截断后就又变为0了  0000 0000 .... 0000 + 1111 ...1111=1111....1111 =1... 1111 因为是无符号数，所以为2^32-1
	//{
	//	printf("%d\n", i);         //所以一直循环，（死循环）打印9、8、7...0 后从2^32-1开始减
	//	if (i <= (pow(2,32)-10))
	//	{
	//		Sleep(10);
	//	}
	//	else{
	//		Sleep(1000);
	//	}
	//}




	//题六：
	//char a[1000];                         //-128~127
	//int i;
	//for (i = 0; i < 1000; i++)
	//{
	//	a[i] = -1 - i;                   //-1、-2...  当执行到a[127]=-1-127=-128后，下一次执行 a[128]=-1-128=1111 1111+1000 0000=0111 1111（截断后）=127
	//	                                 //127再继续减减到0，该0之前元素个数即为strlen(a)的值=-1~-128+127~1=255

	//}
	//printf("%d\n", strlen(a));           //'\0'=0;即求0之前多少个元素。（strlen不带\0)
	

	system("pause");
	return 0;
}